---
marp: true
---


## 动态规划

### #5 最长回文子字符串

用$c[i\dots j] = 1$表示字符串$s[i\dots j]$为回文字符串

那么可以得到以下公式
$$
c[i,j] = 
\begin{cases}
		c[i + 1, j - 1],& \text{s[i] = s[j]}\\0, & \text{s[i] != s[j]}
	\end{cases}
$$
其中
$$
c[i,i] = 1
\\
c[i,i+1] = 1 s[i] = s[j]
$$


### #10 正则表达式匹配

p为空时，若s为空，返回true 若s不为空 返回false

回溯方法：

~~~js
var isMatch = function(s, p) {
    function match(s, p) {
        if(p.length === 0) return (s.length === 0)
        var flag = (s.length !== 0) && (s[0] === p[0] || p[0] === '.')
        if(p.length >= 2 && p[1] === '*') {
            return match(s, p.slice(2)) || (flag && match(s.slice(1), p))
        } else {
            return flag && match(s.slice(1), p.slice(1))
        }
    }
    return match(s, p)
}
~~~

动态规划方法

用一个二维数组$dp[i][j]$记录当前匹配的位置

用i,j 记录当前位置



### #32 最长有效括号

用$dp[i]$表示字符串s中以i位置字符结尾的最长有效括号的长度，当结尾字符为$'('$，$dp[i]$为0

当结尾字符为$')'$时，分以下两种情况讨论：

1. $s[i] = ')'且s[i - 1] = '('$时

$$
dp[i] = dp[i - 2] + 2
$$

2. $s[i] = ')' s[i-1] = ')'$,若$s[i - dp[i - 1] - 1] = '('$

$$
dp[i] = dp[i - 1] + 2 +dp[i - dp[i - 1] - 2]
$$

​		否则 $dp[i] = 0$

 

### #44 通配符匹配

$f[i][j]$表示s的前i个字符和p的前j个字符匹配
$$
当s[i]与p[j]匹配时，即s[i] = p[j] || p[j] = '?', \\f[i][j] = f[i-1][j-1]
\\
\\当p[j] = '*', 
\begin{cases}
		f[i][j] = f[i][j - 1] ,& \text'*'匹配空字符串\\
		f[i][j] = f[i -1][j], & \text '*'匹配s[i]
	\end{cases}
\\初始化时，f[0][i] = (f[0][i - 1]) \&\& p[i] == '*'
$$

### #53 最大子序和

​	$f(i)$表示前i个元素的最大子序和
$$
\begin{cases} 
f(i) = nums[i], &f(i - 1) < 0 \\
f(i) = f(i - 1) + nums[i], &f(i - 1) >=0
\end{cases}
$$
返回f中的最大值即为最大子序和

### #62 不同路径

$f(i, j)$表示到达第i行第j列的路径数
$$
f(i,j) = f(i-1,j) + f(i,j-1)
$$
初始化条件
$$
f(0,i) = 1 \\
f(i,0) = 1
$$
### #63 不同路径 II

和#62思路相同，但需要根据给定的数组将设置障碍处的$f(i,j)$的值设为0

### #64 最小路径和

$f(i, j)$表示到达第i行第j列的最小路径和 ，$grid[i][j]$表示该点数字
$$
f(i,j) = Min\{f(i-1,j) + grid[i][j], f(i,j-1) + grid[i][j]\}
$$

### #70 爬楼梯

$$
f(n) = f(n - 1) + f(n - 2)\\
f(1) = 1\\
f(2) = 2
$$

### #72 编辑距离

$f[i][j]$表示$word1$的前i个字符转换为$word2$的前j个字符的最少操作数

在对两个字符串进行比较时，从后向前进行比较

操作可分为三种：

1. 插入一个字符，则$f[i][j] = f[i][j - 1] + 1$
2. 删除一个字符，则$f[i][j] = f[i - 1][j] + 1$
3. 替换一个字符，则$f[i][j] = f[i - 1][j - 1] + 1$

因此最后得到
$$
f[i][j] = 
\begin{cases}
	f[i-1][j-1], & \text if & word1[i] = word2[j] \\
	min\{f[i][j - 1] + 1,& f[i - 1][j] + 1, & f[i - 1][j - 1] + 1\}
\end{cases}
$$

### #85 最大矩形

### #91 解码方法

$f(i)$表示前i个字符的解码方法的总数

对于$f(i)$，$s[i] $单独编码，则$f[i] = f[i - 1]$，若$s[i] 和 s[i - 1]$合同编码，若$s[i]s[i-1]$在1-26之间，则$f[i] = f[i - 1] + f[i - 2]$否则的话 $f[i] = f[i - 2]$
$$
f[i] = 
\begin{cases}
	f[i - 1] + f[i - 2] & \text s[i]s[i - 1]可被编码
    \\
	f[i - 1]
\end{cases}
$$
注 以上情况不包括0

### #96 不同的二叉搜索树

$$
 f[0] = 1 \\
 f[1] = 1 \\
 f[i] = \sum_{j = 0}^{i - 1}(f[j] \times f[i - 1 - j])
 
$$

### #97 交错字符串

给定三个字符串 $s1, s2, s3$, 验证$ s3 $是否是由$ s1 $和$ s2 $交错组成的。

$f[i][j]$表示$ s1$的前$i$个字符、$s2$的前$j$个字符和$s3$的前$i + j$个字符是否交错插入。
$$
f[i][j] = 
\begin{cases}
f[i - 1][j] & s1[i] = s3[i + j] &\&\&& s2[i] \neq s3[i + j] \\
f[i][j - 1] & s2[i] = s3[i + j] &\&\&& s1[i] \neq s3[i + j] \\
f[i - 1][j] || f[i][j - 1] & s1[i] = s3[i + j] &\&\&& s2[i] = s3[i + j] \\
false & \text else
\end{cases}
\\
初始化条件：f[0][0] = true \\
f[0][i] = 
\begin{cases}
f[0][i - 1] & \text s2[i] = s3[i] \\
false & \text else
\end{cases}
\\
f[i][0]同理
$$


### #115 不同的子序列

给定一个字符串 **S** 和一个字符串 **T**，计算在 **S** 的子序列中 **T** 出现的个数。
$$
f[i][j] =
\begin{cases}
f[i - 1][j] & \text s[i] \neq t[j] \\
f[i - 1][j] + f[i - 1][j - 1] & \text s[i] = t[j]
\end{cases}
$$
初始化条件如下：
$$
f[0][0] = 1 \\
f[0][i] = 0 \\
f[i][0] = 1
$$

### #120 三角形最小路径和

$f[i][j]$表示到达第$i$行第$j$列的最短路径
$$
f[i][j] = 
\begin{cases}
f[i - 1][0] + triangle[i][j] &\text j = 0 \\
f[i - 1][i - 1] + triangle[i][j] & \text j = i \\
min\{f[i - 1][j] + triangle[i][j],f[i - 1][j - 1] + triangle[i][j]\} & \text else
\end{cases}
$$
初始化条件

$f[0][0] = triangle[0][0]$

该方法使用的额外空间为O(NM)

优化：

采用自底向上的思想，上一层只能到达左下和右下
$$
f[j] = min\{f[j], f[j + 1]\} + triangle[i][j]
$$
从最后一层开始向上循环，

最后返回$f[0] $

### #121 买卖股票的最佳时机

普通方法：

用两个指针$i$和$j$分别表示买入股票的时间和卖出股票的时间

当$prices[i] < prices[j]$ 时，比较保存的max和该值大小，保留较大值，$j++$

否则，令 $i=j,j++$

动态规划方法：

$dp[i][k]$表示$i$天进行$k$次交易的最大收益，在第i天可以选择什么都不做，此时$dp[i][k] = dp[i-1][k]$或者选择卖出，则必在第$0-(i-1)$天中的一天选择买入，假设在第j天买入
$$
dp[i][k] = prices[i] - prices[j] + dp[j - 1][k - 1] \qquad \text其中j为使该式最大的(0,i-1)中的一个值
$$

### #139 单词拆分

回溯法（）：

每次拿字符串s的$i$个字符和$wordDict$匹配，匹配成功，换s的下$i$个字符，匹配失败，回溯到上一步，期间使用memo保存结果

动态规划

$dp[i]$ 表示字符串的前i个字符是否与$wordDict$匹配

将前$i$个字符拆分成两部分，$s[0,j]$和$s[j + 1, i]$若$dp[j]$为$true$且$s[j + 1, i]$与$wordDict$匹配，则$dp[i] = true$

在$j$遍历$(0，i)$中，若均不满足上述条件，则$dp[i]=false$

  

###  #395 至少有K个重复字符的最长子串 

找到给定字符串（由小写字符组成）中的最长子串 ***T\*** ， 要求 ***T\*** 中的每一字符出现次数都不少于 *k* 。输出 ***T\*** 的长度。

**示例 1:**

```
输入:
s = "aaabb", k = 3

输出:
3

最长子串为 "aaa" ，其中 'a' 重复了 3 次。
```

**示例 2:**

```
输入:
s = "ababbc", k = 2

输出:
5

最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
```



##### 分治递归解法

用一个map记录数组中每个字母的出现次数

用首尾两个指针依次指向数组，当指向的元素出现次数小于k时，指向下一个元素，这样直到两个指针指向的元素出现次数均不小于k

对这个首尾指针指向的子数组遍历，当其中某个元素的出现次数小于k时，以此元素为界限。将子数组分为两部分，然后进行递归，返回两个结果中的较大者。



### #124 二叉树中的最大路径和

给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例 2:**

```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```



##### 解题思路

首先，考虑实现一个简化的函数 max_gain(node) ，参数是一个顶点，计算它及其子树的最大贡献。

换句话说，就是计算包含这个顶点的最大权值路径。

![image-20191114162748638](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20191114162748638.png)

因此如果可知最后的最大路径和包含 root ，那么答案就是 max_gain(root)。

然而，最大路径可能并不包括根节点，比如下面的这棵树：

![image-20191114162756596](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20191114162756596.png)

这意味着我们要修改上面的函数，在每一步都检查哪种选择更好：是继续当前路径或者以当前节点作为最高节点计算新的路径。

算法：

- 初始化 max_sum 为最小可能的整数并调用函数 max_gain(node = root)。

- 实现 max_gain(node) 检查是继续旧路径还是开始新路径：
  - 边界情况：如果节点为空，那么最大权值是 0 。
  - 对该节点的所有孩子递归调用 max_gain，计算从左右子树的最大权值：left_gain = max(max_gain(node.left), 0) 和 right_gain = max(max_gain(node.right), 0)。
  - 检查是维护旧路径还是创建新路径。创建新路径的权值是：price_newpath = node.val + left_gain + right_gain，当新路径更好的时候更新 max_sum。
  - 对于递归返回的到当前节点的一条最大路径，计算结果为：node.val + max(left_gain, right_gain)。





###  #322 零钱兑换 

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

**示例 1:**

```
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```

**示例 2:**

```
输入: coins = [2], amount = 3
输出: -1
```

**说明**:
你可以认为每种硬币的数量是无限的。

解题思路：

动态规划方法

$dp[i]$表示凑成$i$块钱需要的最少的硬币个数，N为硬币的面额数，
$$
dp[i] = Min\{dp[i - coins[j]] + 1\},0<= j <= N
\\ 其中初始化dp[i] = -1,dp[0] = 0
\\ 注意若是dp[i - coins[j]] < 0,则跳过这个j值
$$




###  #329 矩阵中的最长递增路径 

给定一个整数矩阵，找出最长递增路径的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。

**示例 1:**

```
输入: nums = 
[
  [9,9,4],
  [6,6,8],
  [2,1,1]
] 
输出: 4 
解释: 最长递增路径为 [1, 2, 6, 9]。
```

**示例 2:**

```
输入: nums = 
[
  [3,4,5],
  [3,2,6],
  [2,2,1]
] 
输出: 4 
解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```



记忆化深度优先搜索方法。拿一个数组`cache[i][j]`保存每一次遍历过程中已经访问过的点的最长递增路径长度。



### #889 鸡蛋掉落

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？



**解题思路**

状态可以表示成$(K,N)$，其中 $K$ 为鸡蛋数，$N$ 为楼层数。当我们从第 XX 楼扔鸡蛋的时候：

如果鸡蛋不碎，那么状态变成 $(K, N-X)$，即我们鸡蛋的数目不变，但答案只可能在上方的 N-XN−X 层楼了。也就是说，我们把原问题缩小成了一个规模为 $(K, N-X)$的子问题；

如果鸡蛋碎了，那么状态变成 $(K−1,X−1)$，即我们少了一个鸡蛋，但我们知道答案只可能在第 $X$ 楼下方的 $X-1$ 层楼中了。也就是说，我们把原问题缩小成了一个规模为 $(K-1, X-1)$ 的子问题。

这样一来，我们定义 $dp(K, N)$为在状态 $(K, N)$下最少需要的步数。根据以上分析我们可以列出状态转移方程：
$$
dp(K, N) = 1 + \min\limits_{1 \leq X \leq N} \Big( \max(dp(K-1, X-1), dp(K, N-X)) \Big)
$$


