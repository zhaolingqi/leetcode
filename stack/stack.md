### 最小栈

设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) -- 将元素 x 推入栈中。
- pop() -- 删除栈顶的元素。
- top() -- 获取栈顶元素。
- getMin() -- 检索栈中的最小元素。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```



维护两个栈结构，一个是正常栈，另一个栈是顺序栈



### 数组中的第K个最大元素

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。



将数组排序后取第k个值



  构建由k个值组成的最小堆

  当新进来的数比最小堆的第一个元素大时，删除第一个元素，并加入新的元素，重新堆排序

###   有序矩阵中第K小的元素 

给定一个 *n x n* 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。
请注意，它是排序后的第k小元素，而不是第k个元素。

**示例:**

```
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。
```

**说明:**
你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。

方法一：

维护一个k个元素的最大堆，

方法二：

二分查找

二维数组的最大值max，最小值min，中间值mid

在二维数组中中小于mid的数的数目left，大于mid的数的数量right

如果k大于left则，第k小的数在mid右侧，令min = mid + 1

否则令max = mid



### 滑动窗口最大值

给定一个数组 *nums*，有一个大小为 *k* 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 *k* 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

你可以假设 *k* 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。



使用双向队列，存储数的索引

遍历数组，令$nums[i]$表示比较元素，$tempQue$表示双向队列

对$tempQue$从后往前遍历，当$nums[tempQue[j]]$ < $nums[i]$时，$j--$。

否则$tempQue.push(i)$



每次输出为$tempQue[0]$



###   基本计算器 II 

实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式仅包含非负整数，`+`， `-` ，`*`，`/` 四种运算符和空格 ` `。 整数除法仅保留整数部分。



利用栈求解中缀表达式

两个栈$valStack$存放值，$optStack$存放运算符（一个相同的运算符在栈中的优先级小于在栈外的优先级）

依次读取字符串中的每一个字符$c$，当$c$为数值时，直接存入$valStack$中，当$c$运算符时，将其与$optStack$中的栈顶元素$top$比较。

当$c$的优先级大于$top$时，将c压入栈

当$c$的优先级小于等于$top$时，弹出$valStack$的两个元素与$c$进行计算，并将结果压入$valStack$中。

