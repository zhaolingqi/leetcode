# 链表

### 复制带随机指针的链表 138

给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。

要求返回这个链表的**[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 

 

**示例：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1470150906153-2yxeznm.png)**

```
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

解释：
节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。
```



##### 回溯法：

将整张链表想象成一张图，维护一个名为`visitedNode`的Map保存已经拷贝过的链表结点，`key`为`pre`，value为`cur`  

从 头 指针开始遍历整个图。

1. 我们将链表看做一张图。下图对应的是上面的有向链表的例子，Head 是图的出发节点。

2. 当我们遍历到某个点时，如果我们已经有了当前节点的一个拷贝，我们不需要重复进行拷贝。
3. 如果我们还没拷贝过当前节点，我们创造一个新的节点，并把该节点放到已访问字典中，即：
   visited_dictionary[current_node] = cloned_node_for_current_node.
4. 我们针对两种情况进行回溯调用：一个顺着 random 指针调用，另一个沿着 next 指针调用。步骤 1 中将 random 和 next 指针分别红红色和蓝色标注。然后我们分别对两个指针进行函数递归调用：

空间复杂度$O(n)$ 时间复杂度$O(n)$

##### 方法2（空间复杂度$O(1)$的方法）

1. 遍历原来的链表并拷贝每一个结点，并将拷贝结点放在原结点旁边，创造出一个旧结点和新结点交错的链表，如下图所示。

![image-20191105131751421](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20191105131751421.png)

2. 迭代这个新旧节点交错的链表，并用旧节点的 random 指针去更新对应新节点的 random 指针。比方说， B 的 random 指针指向 A ，意味着 B' 的 random 指针指向 A' 。
3. 将next正确赋值

总共做三次遍历，第一次克隆，第二次正确定位random，第三次得到复制链表



###   环形链表 141

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。



##### 解题思路

快慢指针，确定两个指针，一个指针一次加1，另一个指针一次加2，若两个指针相遇指向同一个结点，则链表有环

### 环形链表 II 142

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

##### 解题思路

如上题，若有环，新建一个指针指向快慢指针在环中的相遇点，另一个指针指向链表头，然后两个指针同时指向下一节点，直到相遇，相遇点即为环的入口



### 排序链表 148

 在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。 



链表归并排序

与数组的归并排序类似，主要是找中间结点，利用快慢指针，慢指针每次跳一步，快指针每次跳两步。当快指针指向链尾的时候，慢指针正好指向链表中间点。



### 相交链表 160

 编写一个程序，找到两个单链表相交的起始节点。 



两个相交的链表从交点开始往后每个结点都相同。可以从后往前，直到找到第一个不同的节点，后面部分即为相交部分。



##### 空间复杂度为$O(1)$的解法

两个指针分别从两个链表的头出发，当遍历到链表尾的时候，重新指向另一个链表的头，当两个指针指向同一个结点时，即为两个单链表相交的起始节点



### 反转链表 206

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？



##### 迭代方法：

```js
    let cur = head
    let pre = null
    while(cur) {
        let temp = cur.next
        cur.next = pre
        pre = cur
        cur = temp
    }
    return pre
```

##### 递归方法：

```js
var reverseList = function (head) {
    if(head === null) return null
    let end = new ListNode(0)
    let newEnd = reverse(head)
    newEnd.next = null
    return end

    function reverse(head) {
        if (head === null || head.next === null) {
            end = head
            return head
        }
        let newHead = reverse(head.next)
        newHead.next = head
        newHead = newHead.next
        return newHead
    }
};
```



### 回文链表 234

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？



##### 空间复杂度$O(n)$的解法

遍历链表，将链表中的每个结点放入数组中，然后从数组的头尾开始一一比较



### 删除链表中的结点

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png)

 

**示例 1:**

```
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

 

**说明:**

- 链表至少包含两个节点。
- 链表中所有节点的值都是唯一的。
- 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
- 不要从你的函数中返回任何结果。

##### 解题思路

因为无法获得原来链表的head，因此考虑将node的next结点中的值赋值给node，然后删去node的next结点即可



###  奇偶链表 42

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

**示例 1:**

```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

**示例 2:**

```
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
```

**说明:**

- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

##### 解题思路

定义两个指针，`odd`和`even`。初始化时，`odd`为`head`，`even`为`head.next`。每次循环，将`odd.next`指向`odd.next.next`，`even.next`指向`even.next.next`，循环结束后，将`odd.next`指向even的头





