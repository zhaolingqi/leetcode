### 只出现一次的数 136

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

##### 方法一：

利用Set，遍历nums，若Set中已有nums[i]，则将其删除，否则添加nums[i]。

最后Set中剩余的数据即为只出现了一次的元素

##### 方法二：

利用Array.prototypr.indexOf和Array.prototypr.lastIndexOf函数进行判断

##### 方法三：

位操作

概念

如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位
$a \oplus 0 = a,a⊕0=a$
如果我们对相同的二进制位做 XOR 运算，返回的结果是 0
$a \oplus a = 0,a⊕a=0$
XOR 满足交换律和结合律
$a \oplus b \oplus a = (a \oplus a) \oplus b = 0  \oplus b = b\\$
所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。



### 直线上最多的点数 149

给定一个二维平面，平面上有 *n* 个点，求最多有多少个点在同一条直线上。

**示例 1:**

```
输入: [[1,1],[2,2],[3,3]]
输出: 3
解释:
^
|
|        o
|     o
|  o  
+------------->
0  1  2  3  4
```

**示例 2:**

```
输入: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
输出: 4
解释:
^
|
|  o
|     o        o
|        o
|  o        o
+------------------->
0  1  2  3  4  5  6
```

##### 解题思路

用`maxCounts[i]`表示从第i个出发向i后的点连线，在同一条直线上点数最多的数目。

计算两点的斜率，并将其存入map中作为键，将点的数目作为值。

具体算法过程：

- 初始化最大点数 max_count = 1 。
- 迭代所有的点 i 从 0 到 N - 2。
  - 对于每个点 i 找出通过该点直线的最大点数`maxCounts[i]`：
    - 初始化通过点 i 直线的最大点数：count = 1。
    - 迭代下一个顶点 j 从 i+1 到 N-1。
    - 如果 j 和 i 重合，更新点 i 相同点的个数duplicates。
    - 否则：
      - 保存通过 i 和 j 的直线。
      - 每步更新 count。
    - 返回结果 max_count_i = count + duplicates。
  - 更新结果 max_count = max(max_count, max_count_i)。

### 分数到小数 166

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

**示例 1:**

```
输入: numerator = 1, denominator = 2
输出: "0.5"
```

**示例 2:**

```
输入: numerator = 2, denominator = 1
输出: "2"
```

**示例 3:**

```
输入: numerator = 2, denominator = 3
输出: "0.(6)"
```

##### 算法

需要用一个哈希表记录余数出现在小数部分的位置，当你发现已经出现的余数，就可以将重复出现的小数部分用括号括起来。

再出发过程中余数可能为 0，意味着不会出现循环小数，立刻停止程序。

就像两数相除问题一样，主义考虑负分数以及极端情况，比如说 
$$
\dfrac{-2147483648}{-1} 
$$


###  阶乘后的零 172

给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

##### 解题思路：

计算5的个数即可。

每5个数加1

每25个数加2

每125个数加3

依此类推



###  计数质数 

统计所有小于非负整数 *n* 的质数的数量。

**示例:**

```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```

##### 思路一：

对小于n的每一个数进行判断是否是质数

判断方法：用n除以2到$\sqrt{n}$如果都不能整除，则该数是质数，否则不是

##### 思路二：

创建一个长度为n的数组，初始化为true，从2开始，2\*2，2\*3,...不都可能是质数，3\*2，3\*3，也都不可能是质数，依此类推，最后统计数组中true的个数即可



